# DeduplicationTracker


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

## DeduplicationTracker Class

The
[`DeduplicationTracker`](https://cj-mills.github.io/cjm-fasthtml-workflows/core/deduplication.html#deduplicationtracker)
ensures that operations are performed exactly once per job within a
user’s session. This is useful for operations that should only happen
once, such as:

- Auto-saving results to disk
- Sending email notifications
- Logging completion events
- Creating database records

The tracker stores job IDs in the session, so tracking persists across
requests but is scoped to each user.

------------------------------------------------------------------------

<a
href="https://github.com/cj-mills/cjm-fasthtml-workflows/blob/main/cjm_fasthtml_workflows/core/deduplication.py#L12"
target="_blank" style="float:right; font-size:smaller">source</a>

### DeduplicationTracker

>  DeduplicationTracker (sess:Any, tracker_id:str)

*Track one-time operations per job to prevent duplicates.*

<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 38%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Type</strong></th>
<th><strong>Details</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>sess</td>
<td>Any</td>
<td>FastHTML session object</td>
</tr>
<tr>
<td>tracker_id</td>
<td>str</td>
<td>Unique identifier for this tracker (e.g., “saved_jobs”,
“sent_notifications”)</td>
</tr>
</tbody>
</table>

## Usage Examples

These examples demonstrate how to use
[`DeduplicationTracker`](https://cj-mills.github.io/cjm-fasthtml-workflows/core/deduplication.html#deduplicationtracker)
to prevent duplicate operations.

``` python
# Create a mock session
mock_session = {}

# Create a tracker for saved jobs
tracker = DeduplicationTracker(mock_session, "saved_jobs")
tracker
```

    <__main__.DeduplicationTracker>

``` python
# Check if job has been processed (initially false)
is_processed = tracker.is_processed("job-123")
print(f"Job-123 processed: {is_processed}")
```

    Job-123 processed: False

``` python
# Mark job as processed
tracker.mark_processed("job-123")
print(f"Job-123 processed: {tracker.is_processed('job-123')}")
print(f"Session state: {mock_session}")
```

    Job-123 processed: True
    Session state: {'dedup_saved_jobs': ['job-123'], '__dedup_saved_jobs_last_modified': 1761793147.8636549}

``` python
# Mark multiple jobs
tracker.mark_processed("job-456")
tracker.mark_processed("job-789")

all_processed = tracker.get_all_processed()
print(f"All processed jobs: {all_processed}")
```

    All processed jobs: {'job-123', 'job-456', 'job-789'}

``` python
# Unmark a job (allow reprocessing)
tracker.unmark_processed("job-456")
print(f"Job-456 processed: {tracker.is_processed('job-456')}")
print(f"Remaining: {tracker.get_all_processed()}")
```

    Job-456 processed: False
    Remaining: {'job-123', 'job-789'}

``` python
# Clear all processed jobs
tracker.clear_all()
print(f"After clearing: {tracker.get_all_processed()}")
print(f"Session state: {mock_session}")
```

    After clearing: set()
    Session state: {'__dedup_saved_jobs_last_modified': 1761793147.915495}

## Multiple Trackers

You can use multiple trackers in the same session for different types of
operations:

``` python
session = {}

# Tracker for saved jobs
save_tracker = DeduplicationTracker(session, "saved_jobs")
save_tracker.mark_processed("job-001")
save_tracker.mark_processed("job-002")

# Tracker for sent notifications
notify_tracker = DeduplicationTracker(session, "sent_notifications")
notify_tracker.mark_processed("job-001")

# Tracker for logged events
log_tracker = DeduplicationTracker(session, "logged_events")
log_tracker.mark_processed("job-001")
log_tracker.mark_processed("job-002")
log_tracker.mark_processed("job-003")

print("Session with multiple trackers:")
for key, value in session.items():
    print(f"  {key}: {value}")
```

    Session with multiple trackers:
      dedup_saved_jobs: ['job-001', 'job-002']
      __dedup_saved_jobs_last_modified: 1761793147.9306018
      dedup_sent_notifications: ['job-001']
      __dedup_sent_notifications_last_modified: 1761793147.9306183
      dedup_logged_events: ['job-003', 'job-001', 'job-002']
      __dedup_logged_events_last_modified: 1761793147.9306488

``` python
# Each tracker is independent
print(f"Job-001 saved: {save_tracker.is_processed('job-001')}")
print(f"Job-001 notified: {notify_tracker.is_processed('job-001')}")
print(f"Job-001 logged: {log_tracker.is_processed('job-001')}")
print(f"\nJob-002 saved: {save_tracker.is_processed('job-002')}")
print(f"Job-002 notified: {notify_tracker.is_processed('job-002')}")
print(f"Job-002 logged: {log_tracker.is_processed('job-002')}")
```

    Job-001 saved: True
    Job-001 notified: True
    Job-001 logged: True

    Job-002 saved: True
    Job-002 notified: False
    Job-002 logged: True

## Real-World Pattern

Here’s a typical pattern for using the tracker to prevent duplicate
saves:

``` python
# Simulate a session
user_session = {}

def save_result_to_disk(job_id, data):
    """Simulated disk save operation."""
    print(f"  [DISK] Saving result for {job_id}: {data}")
    # In real code: write to file, database, etc.

def save_job_result_once(sess, job_id, data):
    """
    Save job result to disk, ensuring it's only saved once.
    
    This prevents duplicate saves even if the route is called multiple times.
    """
    tracker = DeduplicationTracker(sess, "saved_jobs")
    
    if tracker.is_processed(job_id):
        print(f"  [SKIP] Job {job_id} already saved")
        return
    
    try:
        save_result_to_disk(job_id, data)
        tracker.mark_processed(job_id)
        print(f"  [SUCCESS] Job {job_id} saved and marked")
    except Exception as e:
        print(f"  [ERROR] Failed to save job {job_id}: {e}")
        # Note: job is NOT marked as processed, so it can be retried

# Simulate multiple calls (e.g., page refreshes, SSE polling, etc.)
print("First call:")
save_job_result_once(user_session, "job-abc", {"text": "Hello world"})

print("\nSecond call (duplicate):")
save_job_result_once(user_session, "job-abc", {"text": "Hello world"})

print("\nThird call (duplicate):")
save_job_result_once(user_session, "job-abc", {"text": "Hello world"})

print("\nDifferent job:")
save_job_result_once(user_session, "job-xyz", {"text": "Goodbye world"})

print("\nFinal session state:")
user_session
```

    First call:
      [DISK] Saving result for job-abc: {'text': 'Hello world'}
      [SUCCESS] Job job-abc saved and marked

    Second call (duplicate):
      [SKIP] Job job-abc already saved

    Third call (duplicate):
      [SKIP] Job job-abc already saved

    Different job:
      [DISK] Saving result for job-xyz: {'text': 'Goodbye world'}
      [SUCCESS] Job job-xyz saved and marked

    Final session state:

    {'dedup_saved_jobs': ['job-abc', 'job-xyz'],
     '__dedup_saved_jobs_last_modified': 1761793147.9616601}
